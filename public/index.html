<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Backrooms - Multiplayer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #000;
    }
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      text-shadow: 2px 2px 4px #000;
      z-index: 100;
      font-size: 16px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border: 2px solid #ff0;
    }
    #health {
      color: #f00;
      font-size: 18px;
      margin-bottom: 5px;
    }
    #stamina {
      color: #0ff;
      font-size: 16px;
      margin-bottom: 5px;
    }
    #flashlight {
      color: #ff0;
      font-size: 14px;
      margin-top: 5px;
    }
    #chat {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 400px;
      z-index: 100;
    }
    #messages {
      background: rgba(0, 0, 0, 0.9);
      color: #0f0;
      padding: 10px;
      height: 150px;
      overflow-y: auto;
      margin-bottom: 10px;
      font-size: 13px;
      border: 2px solid #0f0;
    }
    .chatMsg {
      margin: 3px 0;
    }
    #chatInputContainer {
      display: none;
    }
    #chatInputContainer.active {
      display: block;
    }
    #chatInput {
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #0ff;
      color: #0ff;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    #chatInput:focus {
      outline: none;
      border-color: #0ff;
      box-shadow: 0 0 10px #0ff;
    }
    #deathScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(255, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 200;
    }
    #deathScreen.active {
      display: flex;
    }
    #deathText {
      color: #f00;
      font-size: 64px;
      text-shadow: 4px 4px 8px #000;
      animation: flicker 0.3s infinite;
      margin-bottom: 20px;
    }
    #respawnBtn {
      padding: 15px 40px;
      background: #f00;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
    }
    #respawnBtn:hover {
      background: #c00;
    }
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    #instructions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: #ff0;
      padding: 40px;
      border: 3px solid #ff0;
      text-align: center;
      z-index: 300;
      max-width: 600px;
    }
    #instructions h1 {
      font-size: 48px;
      margin-bottom: 30px;
      text-shadow: 3px 3px 6px #000;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    #instructions p {
      font-size: 18px;
      margin: 10px 0;
      color: #fff;
    }
    #instructions strong {
      color: #0f0;
    }
    #startBtn {
      margin-top: 30px;
      padding: 15px 50px;
      background: #ff0;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    #startBtn:hover {
      background: #cc0;
    }
    #controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border: 2px solid #0ff;
      color: #0ff;
      z-index: 100;
      font-size: 14px;
    }
    #connectionStatus {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #0ff;
      padding: 30px;
      border: 2px solid #0ff;
      font-size: 20px;
      z-index: 300;
      display: none;
    }
    #connectionStatus.active {
      display: block;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h1>‚ö† THE BACKROOMS ‚ö†</h1>
    <p><strong>WASD</strong> - Move around</p>
    <p><strong>SHIFT</strong> - Sprint</p>
    <p><strong>SPACE</strong> - Jump</p>
    <p><strong>MOUSE</strong> - Look around</p>
    <p><strong>F</strong> - Toggle flashlight</p>
    <p><strong>T</strong> - Open chat</p>
    <p style="margin-top: 20px; color: #f00;">Avoid the red entities. They will hunt you.</p>
    <p style="color: #0f0;">Multiplayer enabled! See other players in green!</p>
    <button id="startBtn">ENTER THE BACKROOMS</button>
  </div>

  <div id="connectionStatus">
    <div>üîå Connecting to server...</div>
  </div>

  <canvas id="gameCanvas"></canvas>
  
  <div id="ui">
    <div id="health">‚ù§ HEALTH: <span id="healthValue">100</span></div>
    <div id="stamina">üîã STAMINA: <span id="staminaValue">100</span></div>
    <div>üë• PLAYERS: <span id="playerCount">0</span></div>
    <div>üìç LEVEL: 0</div>
    <div id="flashlight">üî¶ <span id="flashlightStatus">ON</span></div>
  </div>

  <div id="controls">
    <div>WASD - Move</div>
    <div>SHIFT - Sprint</div>
    <div>SPACE - Jump</div>
    <div>MOUSE - Look</div>
    <div>F - Flashlight</div>
    <div>T - Chat</div>
    <div style="margin-top: 10px; color: #ff0;">CLICK - Lock Mouse</div>
  </div>

  <div id="chat">
    <div id="messages"></div>
    <div id="chatInputContainer">
      <input type="text" id="chatInput" placeholder="Type and press ENTER to send..." maxlength="100">
    </div>
  </div>

  <div id="deathScreen">
    <div id="deathText">YOU DIED</div>
    <button id="respawnBtn">RESPAWN</button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    var scene, camera, renderer, socket;
    var otherPlayers = {};
    var entities = [];
    var walls = [];
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var health = 100;
    var stamina = 100;
    var sprinting = false;
    var chatting = false;
    var gameStarted = false;
    var myPlayerId = null;
    var yaw = 0;
    var pitch = 0;
    var velocity = new THREE.Vector3();
    var canJump = false;
    var flashlightOn = true;
    var flashlight;
    var lastMoveUpdate = 0;

    document.getElementById('startBtn').addEventListener('click', function() {
      document.getElementById('instructions').style.display = 'none';
      document.getElementById('connectionStatus').classList.add('active');
      init();
    });

    document.getElementById('respawnBtn').addEventListener('click', function() {
      location.reload();
    });

    function init() {
      console.log('üéÆ Starting game...');
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 1, 30);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 5);
      
      var canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      var ambientLight = new THREE.AmbientLight(0x4a3f2f, 0.15);
      scene.add(ambientLight);
      
      flashlight = new THREE.SpotLight(0xffffee, 1.5, 25, Math.PI / 6, 0.5);
      flashlight.position.copy(camera.position);
      flashlight.target.position.set(0, 0, -1);
      flashlight.castShadow = true;
      flashlight.shadow.mapSize.width = 1024;
      flashlight.shadow.mapSize.height = 1024;
      scene.add(flashlight);
      scene.add(flashlight.target);
      
      createBackrooms();
      
      console.log('üåê Connecting to server...');
      socket = io();
      
      socket.on('connect', function() {
        console.log('‚úÖ Connected!');
        document.getElementById('connectionStatus').classList.remove('active');
        gameStarted = true;
        addChatMessage('‚úÖ Connected to server!');
        addChatMessage('üí° Press F to toggle flashlight');
        addChatMessage('üèÉ Hold SHIFT to sprint');
        addChatMessage('‚¨ÜÔ∏è Press SPACE to jump');
      });
      
      socket.on('init', function(data) {
        console.log('üì¶ Got init data:', data);
        myPlayerId = data.id;
        
        for (var id in data.players) {
          if (id !== data.id) {
            addOtherPlayer(data.players[id]);
          }
        }
        
        data.entities.forEach(function(e) {
          addEntity(e);
        });
        updatePlayerCount();
      });
      
      socket.on('playerJoined', function(playerData) {
        addOtherPlayer(playerData);
        updatePlayerCount();
        addChatMessage('üë§ Player joined the backrooms...');
      });
      
      socket.on('playerMoved', function(data) {
        if (otherPlayers[data.id]) {
          otherPlayers[data.id].mesh.position.set(data.x, data.y, data.z);
          otherPlayers[data.id].mesh.rotation.y = data.rotation;
        }
      });
      
      socket.on('playerLeft', function(id) {
        if (otherPlayers[id]) {
          scene.remove(otherPlayers[id].mesh);
          delete otherPlayers[id];
          updatePlayerCount();
          addChatMessage('üëã Player left the backrooms...');
        }
      });
      
      socket.on('entitiesUpdate', function(entitiesData) {
        entitiesData.forEach(function(e, i) {
          if (entities[i]) {
            entities[i].position.set(e.x, e.y, e.z);
          }
        });
      });
      
      socket.on('damage', function(newHealth) {
        health = newHealth;
        document.getElementById('healthValue').textContent = health;
        flashDamage();
      });
      
      socket.on('death', function() {
        document.getElementById('deathScreen').classList.add('active');
      });
      
      socket.on('chatMessage', function(data) {
        var isMe = data.id === myPlayerId;
        addChatMessage((isMe ? 'You' : data.username) + ': ' + data.message);
      });
      
      socket.on('disconnect', function() {
        addChatMessage('‚ùå Disconnected from server');
        document.getElementById('connectionStatus').classList.add('active');
        document.getElementById('connectionStatus').innerHTML = '<div>‚ùå Disconnected. Refresh to reconnect.</div>';
      });
      
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      document.addEventListener('mousemove', handleMouseMove);
      
      canvas.addEventListener('click', function() {
        if (gameStarted && !chatting) {
          canvas.requestPointerLock();
        }
      });
      
      var chatInput = document.getElementById('chatInput');
      chatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          var msg = chatInput.value.trim();
          if (msg && socket) {
            socket.emit('chat', msg);
            chatInput.value = '';
          }
          closeChat();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          closeChat();
        }
      });
      
      animate();
    }

    function handleKeyDown(e) {
      if (chatting) return;
      
      var key = e.key.toLowerCase();
      
      if (key === 't') {
        e.preventDefault();
        openChat();
        return;
      }
      
      if (key === 'f') {
        flashlightOn = !flashlightOn;
        flashlight.intensity = flashlightOn ? 1.5 : 0;
        document.getElementById('flashlightStatus').textContent = flashlightOn ? 'ON' : 'OFF';
        addChatMessage(flashlightOn ? 'üî¶ Flashlight ON' : 'üî¶ Flashlight OFF');
        if (socket) socket.emit('flashlight', flashlightOn);
      }
      
      if (key === 'w') moveForward = true;
      if (key === 's') moveBackward = true;
      if (key === 'a') moveLeft = true;
      if (key === 'd') moveRight = true;
      if (key === 'shift') sprinting = true;
      if (key === ' ' && canJump) {
        velocity.y = 5;
        canJump = false;
      }
    }

    function handleKeyUp(e) {
      var key = e.key.toLowerCase();
      if (key === 'w') moveForward = false;
      if (key === 's') moveBackward = false;
      if (key === 'a') moveLeft = false;
      if (key === 'd') moveRight = false;
      if (key === 'shift') sprinting = false;
    }

    function handleMouseMove(e) {
      if (!gameStarted || chatting || !document.pointerLockElement) return;
      
      yaw -= e.movementX * 0.002;
      pitch -= e.movementY * 0.002;
      pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }

    function openChat() {
      chatting = true;
      document.exitPointerLock();
      document.getElementById('chatInputContainer').classList.add('active');
      document.getElementById('chatInput').focus();
    }

    function closeChat() {
      chatting = false;
      document.getElementById('chatInputContainer').classList.remove('active');
      document.getElementById('chatInput').value = '';
      document.getElementById('gameCanvas').requestPointerLock();
    }

    function createBackrooms() {
      var floorGeometry = new THREE.PlaneGeometry(200, 200);
      var floorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xd4c5a0,
        roughness: 0.95
      });
      var floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      
      var ceiling = floor.clone();
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = 3;
      ceiling.material = new THREE.MeshStandardMaterial({ 
        color: 0xe8dcc8,
        roughness: 0.9
      });
      scene.add(ceiling);
      
      var wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xf0e6d2,
        roughness: 0.9
      });
      
      var cellSize = 6;
      for (var x = -5; x < 5; x++) {
        for (var z = -5; z < 5; z++) {
          if (x === 0 && z === 0) continue;
          
          if (Math.random() > 0.4) {
            var vertical = Math.random() > 0.5;
            var wall = new THREE.Mesh(
              new THREE.BoxGeometry(vertical ? 0.3 : cellSize, 3, vertical ? cellSize : 0.3),
              wallMaterial
            );
            wall.position.set(
              x * cellSize + (Math.random() - 0.5) * 2,
              1.5,
              z * cellSize + (Math.random() - 0.5) * 2
            );
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
          }
        }
      }
      
      for (var lx = -40; lx < 40; lx += 12) {
        for (var lz = -40; lz < 40; lz += 12) {
          var light = new THREE.PointLight(0xffffcc, 0.4, 15);
          light.position.set(lx + Math.random() * 4, 2.8, lz + Math.random() * 4);
          light.castShadow = true;
          scene.add(light);
          
          var lightBox = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.08, 0.5),
            new THREE.MeshBasicMaterial({ color: 0xffffee })
          );
          lightBox.position.copy(light.position);
          scene.add(lightBox);
        }
      }
    }

    function addOtherPlayer(data) {
      var mesh = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.3, 1.6, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0x00ff88,
          emissive: 0x00ff88,
          emissiveIntensity: 0.3
        })
      );
      mesh.position.set(data.x, data.y, data.z);
      mesh.castShadow = true;
      scene.add(mesh);
      otherPlayers[data.id] = { mesh: mesh };
    }

    function addEntity(data) {
      var mesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 2, 0.6),
        new THREE.MeshStandardMaterial({ 
          color: 0x050505,
          emissive: 0xff0000,
          emissiveIntensity: 0.8
        })
      );
      mesh.position.set(data.x, data.y, data.z);
      mesh.castShadow = true;
      
      var eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
      var eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      var leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.15, 0.5, 0.3);
      mesh.add(leftEye);
      var rightEye = leftEye.clone();
      rightEye.position.set(0.15, 0.5, 0.3);
      mesh.add(rightEye);
      
      scene.add(mesh);
      entities.push(mesh);
    }

    function updatePlayerCount() {
      document.getElementById('playerCount').textContent = Object.keys(otherPlayers).length + 1;
    }

    function addChatMessage(msg) {
      var messages = document.getElementById('messages');
      var div = document.createElement('div');
      div.className = 'chatMsg';
      div.textContent = msg;
      messages.appendChild(div);
      messages.scrollTop = messages.scrollHeight;
      
      if (messages.children.length > 50) {
        messages.removeChild(messages.firstChild);
      }
    }

    function flashDamage() {
      document.body.style.background = '#f00';
      setTimeout(function() { 
        document.body.style.background = '#000'; 
      }, 100);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      if (!chatting && gameStarted) {
        var delta = 0.016;
        var speed = sprinting && stamina > 0 ? 0.12 : 0.08;
        
        if (sprinting && (moveForward || moveBackward || moveLeft || moveRight)) {
          stamina = Math.max(0, stamina - 0.3);
        } else {
          stamina = Math.min(100, stamina + 0.15);
        }
        document.getElementById('staminaValue').textContent = Math.round(stamina);
        
        var forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        forward.y = 0;
        forward.normalize();
        
        var right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        right.y = 0;
        right.normalize();
        
        var moved = false;
        var moveVector = new THREE.Vector3();
        
        if (moveForward) {
          moveVector.add(forward.multiplyScalar(speed));
          moved = true;
        }
        if (moveBackward) {
          moveVector.add(forward.multiplyScalar(-speed));
          moved = true;
        }
        if (moveLeft) {
          moveVector.add(right.multiplyScalar(-speed));
          moved = true;
        }
        if (moveRight) {
          moveVector.add(right.multiplyScalar(speed));
          moved = true;
        }
        
        velocity.y -= 15 * delta;
        
        var newPosition = camera.position.clone().add(moveVector);
        newPosition.y += velocity.y * delta;
        
        if (newPosition.y < 1.6) {
          newPosition.y = 1.6;
          velocity.y = 0;
          canJump = true;
        }
        
        var canMove = true;
        var playerBox = new THREE.Box3().setFromCenterAndSize(
          newPosition,
          new THREE.Vector3(0.6, 1.6, 0.6)
        );
        
        for (var i = 0; i < walls.length; i++) {
          var wallBox = new THREE.Box3().setFromObject(walls[i]);
          if (playerBox.intersectsBox(wallBox)) {
            canMove = false;
            break;
          }
        }
        
        if (canMove) {
          camera.position.copy(newPosition);
        }
        
        var now = Date.now();
        if (socket && moved && now - lastMoveUpdate > 50) {
          socket.emit('move', {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            rotation: yaw
          });
          lastMoveUpdate = now;
        }
      }
      
      flashlight.position.copy(camera.position);
      var direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);
      flashlight.target.position.copy(camera.position).add(direction);
      
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
