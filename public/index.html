<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Backrooms Multiplayer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #000;
    }
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      text-shadow: 2px 2px 4px #000;
      z-index: 100;
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      padding: 15px;
      border: 2px solid #ff0;
    }
    #health {
      color: #f00;
      font-size: 18px;
      margin-bottom: 5px;
    }
    #chat {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 400px;
      z-index: 100;
    }
    #messages {
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 10px;
      height: 150px;
      overflow-y: auto;
      margin-bottom: 10px;
      font-size: 13px;
      border: 2px solid #0f0;
    }
    .chatMsg {
      margin: 3px 0;
    }
    #chatInput {
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #0f0;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      display: none;
    }
    #chatInput:focus {
      outline: none;
      border-color: #0ff;
    }
    #deathScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(255, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 200;
    }
    #deathScreen.active {
      display: flex;
    }
    #deathText {
      color: #f00;
      font-size: 64px;
      text-shadow: 4px 4px 8px #000;
      animation: flicker 0.3s infinite;
      margin-bottom: 20px;
    }
    #respawnBtn {
      padding: 15px 40px;
      background: #f00;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
    }
    #respawnBtn:hover {
      background: #c00;
    }
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    #instructions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: #ff0;
      padding: 40px;
      border: 3px solid #ff0;
      text-align: center;
      z-index: 300;
      max-width: 600px;
    }
    #instructions h1 {
      font-size: 48px;
      margin-bottom: 30px;
      text-shadow: 3px 3px 6px #000;
    }
    #instructions p {
      font-size: 18px;
      margin: 10px 0;
      color: #fff;
    }
    #instructions strong {
      color: #0f0;
    }
    #startBtn {
      margin-top: 30px;
      padding: 15px 50px;
      background: #ff0;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    #startBtn:hover {
      background: #cc0;
    }
    #controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.5);
      padding: 15px;
      border: 2px solid #0ff;
      color: #0ff;
      z-index: 100;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h1>‚ö† THE BACKROOMS ‚ö†</h1>
    <p><strong>WASD</strong> - Move around</p>
    <p><strong>MOUSE</strong> - Look around</p>
    <p><strong>ENTER</strong> - Open chat</p>
    <p><strong>ESC</strong> - Close chat</p>
    <p style="margin-top: 20px; color: #f00;">Avoid the entities. They hunt in the dark.</p>
    <p style="color: #0f0;">Share this URL with friends to play together!</p>
    <button id="startBtn" onclick="startGame()">ENTER THE BACKROOMS</button>
  </div>

  <canvas id="gameCanvas"></canvas>
  
  <div id="ui">
    <div id="health">‚ù§ HEALTH: <span id="healthValue">100</span></div>
    <div>üë• PLAYERS: <span id="playerCount">1</span></div>
    <div>üìç LEVEL: 0</div>
  </div>

  <div id="controls">
    <div>WASD - Move</div>
    <div>MOUSE - Look</div>
    <div>ENTER - Chat</div>
  </div>

  <div id="chat">
    <div id="messages"></div>
    <input type="text" id="chatInput" placeholder="Type message and press Enter..." maxlength="100">
  </div>

  <div id="deathScreen">
    <div id="deathText">YOU DIED</div>
    <button id="respawnBtn" onclick="location.reload()">RESPAWN</button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, socket;
    let otherPlayers = {};
    let entities = [];
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let health = 100;
    let chatting = false;
    let gameStarted = false;
    let myPlayerId = null;
    let lastEmitTime = 0;

    function startGame() {
      document.getElementById('instructions').style.display = 'none';
      gameStarted = true;
      
      // Request pointer lock
      const canvas = document.getElementById('gameCanvas');
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
      canvas.requestPointerLock();
      
      init();
      addChatMessage('üéÆ Welcome to the Backrooms! Press ENTER to chat.');
    }

    function init() {
      console.log('Initializing game...');
      
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);
      scene.fog = new THREE.Fog(0x1a1a1a, 10, 60);
      
      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 5);
      
      // Renderer
      const canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xd4c5a0, 0.4);
      scene.add(ambientLight);
      
      // Create backrooms environment
      createBackrooms();
      
      console.log('Connecting to server...');
      
      // Socket connection
      socket = io();
      
      socket.on('connect', () => {
        console.log('Connected to server!');
      });
      
      socket.on('init', (data) => {
        console.log('Received init data:', data);
        myPlayerId = data.id;
        
        // Add other players
        for (let id in data.players) {
          if (id !== data.id) {
            addOtherPlayer(data.players[id]);
          }
        }
        
        // Add entities
        data.entities.forEach(e => addEntity(e));
        
        updatePlayerCount();
        addChatMessage('‚úÖ Connected! You can now see other players.');
      });
      
      socket.on('playerJoined', (playerData) => {
        console.log('Player joined:', playerData);
        addOtherPlayer(playerData);
        updatePlayerCount();
        addChatMessage('üë§ A player joined the game');
      });
      
      socket.on('playerMoved', (data) => {
        if (otherPlayers[data.id]) {
          otherPlayers[data.id].mesh.position.set(data.x, data.y, data.z);
          otherPlayers[data.id].mesh.rotation.y = data.rotation;
        }
      });
      
      socket.on('playerLeft', (id) => {
        console.log('Player left:', id);
        if (otherPlayers[id]) {
          scene.remove(otherPlayers[id].mesh);
          delete otherPlayers[id];
          updatePlayerCount();
          addChatMessage('üëã A player left the game');
        }
      });
      
      socket.on('entitiesUpdate', (entitiesData) => {
        entitiesData.forEach((e, i) => {
          if (entities[i]) {
            entities[i].position.set(e.x, e.y, e.z);
          }
        });
      });
      
      socket.on('damage', (newHealth) => {
        health = newHealth;
        document.getElementById('healthValue').textContent = health;
        flashDamage();
      });
      
      socket.on('death', () => {
        document.getElementById('deathScreen').classList.add('active');
        addChatMessage('üíÄ You died!');
      });
      
      socket.on('chatMessage', (data) => {
        const isMe = data.id === myPlayerId;
        addChatMessage(`${isMe ? 'You' : 'Player'}: ${data.message}`);
      });
      
      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        addChatMessage('‚ö† Disconnected from server');
      });
      
      // Controls
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousemove', onMouseMove);
      
      // Pointer lock change
      document.addEventListener('pointerlockchange', () => {
        if (!document.pointerLockElement && !chatting) {
          console.log('Pointer lock lost');
        }
      });
      
      // Chat controls
      const chatInput = document.getElementById('chatInput');
      chatInput.addEventListener('keydown', (e) => {
        e.stopPropagation();
        
        if (e.key === 'Enter') {
          const msg = chatInput.value.trim();
          if (msg && socket) {
            socket.emit('chat', msg);
            chatInput.value = '';
          }
          chatInput.style.display = 'none';
          chatting = false;
          
          // Re-lock pointer
          const canvas = document.getElementById('gameCanvas');
          canvas.requestPointerLock();
          
        } else if (e.key === 'Escape') {
          chatInput.style.display = 'none';
          chatInput.value = '';
          chatting = false;
          
          const canvas = document.getElementById('gameCanvas');
          canvas.requestPointerLock();
        }
      });
      
      console.log('Game initialized! Starting animation loop...');
      animate();
    }

    function createBackrooms() {
      // Floor
      const floorGeometry = new THREE.PlaneGeometry(300, 300);
      const floorTexture = new THREE.TextureRepeat = 20;
      const floorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xc9b896,
        roughness: 0.9,
        metalness: 0.1
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      
      // Ceiling
      const ceilingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xd4c5a0,
        roughness: 0.8
      });
      const ceiling = new THREE.Mesh(floorGeometry, ceilingMaterial);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = 3;
      ceiling.receiveShadow = true;
      scene.add(ceiling);
      
      // Walls - create a maze-like structure
      const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xe6d5a8,
        roughness: 0.9
      });
      
      // Create grid of walls
      for (let x = -50; x < 50; x += 10) {
        for (let z = -50; z < 50; z += 10) {
          if (Math.random() > 0.3) {
            const isVertical = Math.random() > 0.5;
            const wallGeometry = new THREE.BoxGeometry(
              isVertical ? 0.3 : 8,
              3,
              isVertical ? 8 : 0.3
            );
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x + Math.random() * 5, 1.5, z + Math.random() * 5);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
          }
        }
      }
      
      // Fluorescent lights
      for (let x = -40; x < 40; x += 15) {
        for (let z = -40; z < 40; z += 15) {
          const light = new THREE.PointLight(0xffffcc, 1, 25);
          light.position.set(x + Math.random() * 5, 2.7, z + Math.random() * 5);
          light.castShadow = true;
          scene.add(light);
          
          // Light fixture
          const lightBox = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.1, 0.7),
            new THREE.MeshBasicMaterial({ color: 0xffffdd })
          );
          lightBox.position.copy(light.position);
          scene.add(lightBox);
        }
      }
      
      console.log('Backrooms environment created');
    }

    function addOtherPlayer(playerData) {
      const geometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
      const material = new THREE.MeshStandardMaterial({ 
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.3
      });
      const playerMesh = new THREE.Mesh(geometry, material);
      playerMesh.position.set(playerData.x, playerData.y, playerData.z);
      playerMesh.castShadow = true;
      scene.add(playerMesh);
      
      otherPlayers[playerData.id] = { mesh: playerMesh };
      console.log('Added other player:', playerData.id);
    }

    function addEntity(entityData) {
      const geometry = new THREE.BoxGeometry(0.8, 2.5, 0.8);
      const material = new THREE.MeshStandardMaterial({ 
        color: 0x000000,
        emissive: 0xff0000,
        emissiveIntensity: 0.8
      });
      const entityMesh = new THREE.Mesh(geometry, material);
      entityMesh.position.set(entityData.x, entityData.y, entityData.z);
      entityMesh.castShadow = true;
      scene.add(entityMesh);
      entities.push(entityMesh);
      console.log('Added entity:', entityData.id);
    }

    function onKeyDown(e) {
      if (chatting) return;
      
      if (e.key === 'Enter') {
        chatting = true;
        const chatInput = document.getElementById('chatInput');
        chatInput.style.display = 'block';
        chatInput.focus();
        document.exitPointerLock();
        return;
      }
      
      switch(e.key.toLowerCase()) {
        case 'w': moveForward = true; break;
        case 's': moveBackward = true; break;
        case 'a': moveLeft = true; break;
        case 'd': moveRight = true; break;
      }
    }

    function onKeyUp(e) {
      switch(e.key.toLowerCase()) {
        case 'w': moveForward = false; break;
        case 's': moveBackward = false; break;
        case 'a': moveLeft = false; break;
        case 'd': moveRight = false; break;
      }
    }

    let yaw = 0;
    let pitch = 0;

    function onMouseMove(e) {
      if (!gameStarted || chatting || !document.pointerLockElement) return;
      
      const sensitivity = 0.002;
      yaw -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      
      // Clamp pitch
      pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }

    function updatePlayerCount() {
      const count = Object.keys(otherPlayers).length + 1;
      document.getElementById('playerCount').textContent = count;
    }

    function addChatMessage(msg) {
      const messages = document.getElementById('messages');
      const msgEl = document.createElement('div');
      msgEl.className = 'chatMsg';
      msgEl.textContent = msg;
      messages.appendChild(msgEl);
      messages.scrollTop = messages.scrollHeight;
      
      // Auto-hide old messages
      if (messages.children.length > 50) {
        messages.removeChild(messages.firstChild);
      }
    }

    function flashDamage() {
      document.body.style.background = '#f00';
      setTimeout(() => { document.body.style.background = '#000'; }, 100);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      if (!chatting && gameStarted) {
        // Movement
        const speed = 0.15;
        const direction = new THREE.Vector3();
        
        if (moveForward) direction.z -= 1;
        if (moveBackward) direction.z += 1;
        if (moveLeft) direction.x -= 1;
        if (moveRight) direction.x += 1;
        
        if (direction.length() > 0) {
          direction.normalize();
          
          // Apply camera rotation to movement
          const forward = new THREE.Vector3(0, 0, -1);
          forward.applyQuaternion(camera.quaternion);
          forward.y = 0;
          forward.normalize();
          
          const right = new THREE.Vector3(1, 0, 0);
          right.applyQuaternion(camera.quaternion);
          right.y = 0;
          right.normalize();
          
          camera.position.add(forward.multiplyScalar(direction.z * speed));
          camera.position.add(right.multiplyScalar(direction.x * speed));
          
          // Send position to server (throttled)
          const now = Date.now();
          if (socket && now - lastEmitTime > 50) {
            socket.emit('move', {
              x: camera.position.x,
              y: camera.position.y,
              z: camera.position.z,
              rotation: yaw
            });
            lastEmitTime = now;
          }
        }
      }
      
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Click to re-lock pointer if lost
    document.getElementById('gameCanvas').addEventListener('click', () => {
      if (gameStarted && !chatting) {
        const canvas = document.getElementById('gameCanvas');
        canvas.requestPointerLock();
      }
    });
  </script>
</body>
</html>
